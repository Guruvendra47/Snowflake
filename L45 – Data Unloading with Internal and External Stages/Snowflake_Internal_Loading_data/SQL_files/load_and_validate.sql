-- load_and_validate.sql
-- 1) If you are using SnowSQL (for internal stage), upload a file to the internal stage:
-- snowsql -c <conn> -f ... or use PUT inside SnowSQL (PUT works only for internal stages)
-- Example (run from local using SnowSQL):
-- PUT file://./data/sample_customers.csv @DEMO_DATABASE.DEMO_SCHEMA.DEMO_STAGE AUTO_COMPRESS=TRUE;

-- 2) List files in stage
LIST @DEMO_DATABASE.DEMO_SCHEMA.DEMO_STAGE;

-- 3) COPY INTO a TEMP table for validation (recommended)
CREATE OR REPLACE TEMP TABLE tmp_customers_stage LIKE DEMO_DATABASE.DEMO_SCHEMA.CUSTOMER_CVS_FF;

COPY INTO tmp_customers_stage
FROM @DEMO_DATABASE.DEMO_SCHEMA.DEMO_STAGE (FILE_FORMAT => 'DEMO_DATABASE.DEMO_SCHEMA.CUSTOMER_CSV_FF')
FILES = ('sample_customers.csv')
ON_ERROR = 'ABORT_STATEMENT'  -- during dev use ABORT_STATEMENT to see errors
VALIDATION_MODE = RETURN_ERRORS; -- use RETURN_ERRORS to preview parsing issues without inserting

-- 4) If validation looks good, load into target table using a MERGE (idempotent pattern)
-- First stage data into another temp table (no SOURCE_FILE present automatically; you can use METADATA$FILENAME)
CREATE OR REPLACE TEMP TABLE tmp_customers_load AS
SELECT $1:CUST_ID::VARCHAR AS CUST_ID,
       $1:CREDIT_CARD_NUMBER::VARCHAR AS CREDIT_CARD_NUMBER,
       $1:BALANCE::NUMBER(10,2) AS BALANCE,
       $1:PURCHASES::NUMBER(10,2) AS PURCHASES,
       $1:INSTALLMENTS_PURCHASES::NUMBER(10,2) AS INSTALLMENTS_PURCHASES,
       $1:CASH_ADVANCE::NUMBER(10,2) AS CASH_ADVANCE,
       $1:CREDIT_LIMIT::NUMBER(10,2) AS CREDIT_LIMIT,
       $1:PAYMENTS::NUMBER(10,2) AS PAYMENTS,
       $1:MINIMUM_PAYMENTS::NUMBER(10,2) AS MINIMUM_PAYMENTS,
       $1:TENURE::NUMBER(10,2) AS TENURE,
       TO_DATE($1:DATE_OF_TXN::VARCHAR,'YYYY-MM-DD') AS DATE_OF_TXN,
       METADATA$FILENAME AS SOURCE_FILE,
       CURRENT_TIMESTAMP() AS LOADED_AT
FROM @DEMO_DATABASE.DEMO_SCHEMA.DEMO_STAGE (FILE_FORMAT => 'DEMO_DATABASE.DEMO_SCHEMA.CUSTOMER_CSV_FF')
FILES = ('sample_customers.csv');

-- 5) MERGE into final table to avoid duplicates (assuming CUST_ID + DATE_OF_TXN identifies a record)
MERGE INTO DEMO_DATABASE.DEMO_SCHEMA.CUSTOMER_CVS_FF T
USING (
  SELECT * FROM tmp_customers_load
) S
ON T.CUST_ID = S.CUST_ID AND T.DATE_OF_TXN = S.DATE_OF_TXN
WHEN MATCHED THEN UPDATE SET
  T.CREDIT_CARD_NUMBER = S.CREDIT_CARD_NUMBER,
  T.BALANCE = S.BALANCE,
  T.PURCHASES = S.PURCHASES,
  T.INSTALLMENTS_PURCHASES = S.INSTALLMENTS_PURCHASES,
  T.CASH_ADVANCE = S.CASH_ADVANCE,
  T.CREDIT_LIMIT = S.CREDIT_LIMIT,
  T.PAYMENTS = S.PAYMENTS,
  T.MINIMUM_PAYMENTS = S.MINIMUM_PAYMENTS,
  T.TENURE = S.TENURE,
  T.SOURCE_FILE = S.SOURCE_FILE,
  T.LOADED_AT = S.LOADED_AT
WHEN NOT MATCHED THEN INSERT (
  CUST_ID, CREDIT_CARD_NUMBER, BALANCE, PURCHASES, INSTALLMENTS_PURCHASES,
  CASH_ADVANCE, CREDIT_LIMIT, PAYMENTS, MINIMUM_PAYMENTS, TENURE, DATE_OF_TXN,
  SOURCE_FILE, LOADED_AT
) VALUES (
  S.CUST_ID, S.CREDIT_CARD_NUMBER, S.BALANCE, S.PURCHASES, S.INSTALLMENTS_PURCHASES,
  S.CASH_ADVANCE, S.CREDIT_LIMIT, S.PAYMENTS, S.MINIMUM_PAYMENTS, S.TENURE, S.DATE_OF_TXN,
  S.SOURCE_FILE, S.LOADED_AT
);

-- 6) Duplicate check (same as your query but applied to final table)
SELECT CUST_ID, COUNT(*) AS TOTAL_COUNT
FROM DEMO_DATABASE.DEMO_SCHEMA.CUSTOMER_CVS_FF
GROUP BY CUST_ID
HAVING COUNT(*) > 1
ORDER BY 2 DESC;

-- 7) Clean-up temp objects if desired
DROP TABLE IF EXISTS tmp_customers_stage;
DROP TABLE IF EXISTS tmp_customers_load;
